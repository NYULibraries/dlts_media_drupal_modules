<?php

/**
 * Implementation of hook_theme().
 */
function dlts_media_api_theme() {
  return array(
    'dlts_media_api_oembed' => array(
      'arguments' => array(
        'url' => NULL,
        'width' => NULL,
        'height' => NULL,
      ),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function dlts_media_api_menu() {
  return array(
    'clip/%dlts_clip/mode/oembed' => array(
      'title' => 'Embed',
      'access arguments' => array('access content'),
      'page arguments' => array(1),
      'page callback' => 'dlts_media_api_embed_using_id',
      'delivery callback' => 'dlts_utilities_deliver_json',
    ),
    'creativework/%dlts_creativework/mode/oembed' => array(
      'title' => 'Embed',
      'access arguments' => array('access content'),
      'page arguments' => array(1),
      'page callback' => 'dlts_media_api_embed_using_id',
      'delivery callback' => 'dlts_utilities_deliver_json',
    ),
    'playlist/%dlts_playlist/mode/oembed' => array(
      'title' => 'Embed',
      'access arguments' => array('access content'),
      'page arguments' => array(1),
      'page callback' => 'dlts_media_api_embed_using_id',
      'delivery callback' => 'dlts_utilities_deliver_json',
    ),
  );
}

/**
 * A wildcard loader for dlts_clip nodes, using the clip identifier.
 *
 * @parameter $identifier
 *  The value of field_identifier for a dlts_clip node.
 *
 * @return
 * A node object with the given value for field_identifier.
 *
 * @todo
 * field_identifier is supposed to be unique across all books, but we do
 	* no checking of this assumption.
 	* @todo
 	* Does the query need to be tagged as node_access? We're checking node_access
 	* via the menu system, but since the loader is called before access is
 	* checked, adding a check here might save an entity_load if the user's not
 	* going to have access anyway, at the cost of an extra JOIN here.
 	*/
 function dlts_clip_load ( $identifier ) {

  $query = new EntityFieldQuery;

  $identifier = filter_xss($identifier);

  $result = $query
              ->entityCondition('entity_type', 'node')
              ->entityCondition('bundle', 'dlts_clip')
              ->propertyCondition('status', 1)
              ->fieldCondition('field_identifier', 'value', $identifier, '=')
              ->addTag('node_access')
              ->execute();

  if ( !empty($result['node']) ) {
  	$keys = array_keys( $result['node'] );
  	return node_load( array_pop( $keys ) );
  }

  else {
  	return FALSE;
  }
}

/**
 * A wildcard loader for dlts_creativework nodes, using the CreativeWork identifier.
 *
 * @parameter $identifier
 *  The value of field_identifier for a dtls_creativework node.
 *
 * @return
 * A node object with the given value for field_identifier.
 *
 * @todo
 * field_identifier is supposed to be unique across all CreativeWork, but we do
 	* no checking of this assumption.
 	* @todo
 	* Does the query need to be tagged as node_access? We're checking node_access
 	* via the menu system, but since the loader is called before access is
 	* checked, adding a check here might save an entity_load if the user's not
 	* going to have access anyway, at the cost of an extra JOIN here.
 	*/
 function dlts_creativework_load ( $identifier ) {

  $query = new EntityFieldQuery;

  $identifier = filter_xss($identifier);

  $result = $query
              ->entityCondition('entity_type', 'node')
              ->entityCondition('bundle', 'dlts_creativework')
              ->propertyCondition('status', 1)
              ->fieldCondition('field_identifier', 'value', $identifier, '=')
              ->addTag('node_access')
              ->execute();

  if ( !empty($result['node']) ) {
  	$keys = array_keys( $result['node'] );
  	return node_load( array_pop( $keys ) );
  }

  else {
  	return FALSE;
  }
}

/**
 * A wildcard loader for dlts_playlist nodes, using the playlist identifier.
 *
 * @parameter $identifier
 *  The value of field_identifier for a dlts_playlist node.
 *
 * @return
 * A node object with the given value for field_identifier.
 *
 * @todo
 * field_identifier is supposed to be unique across all playlist, but we do
 	* no checking of this assumption.
 	* @todo
 	* Does the query need to be tagged as node_access? We're checking node_access
 	* via the menu system, but since the loader is called before access is
 	* checked, adding a check here might save an entity_load if the user's not
 	* going to have access anyway, at the cost of an extra JOIN here.
 	*/
 function dlts_playlist_load ( $identifier ) {

  $query = new EntityFieldQuery;

  $identifier = filter_xss($identifier);

  $result = $query
              ->entityCondition('entity_type', 'node')
              ->entityCondition('bundle', 'dlts_playlist')
              ->propertyCondition('status', 1)
              ->fieldCondition('field_identifier', 'value', $identifier, '=')
              ->addTag('node_access')
              ->execute();

  if ( !empty($result['node']) ) {
  	$keys = array_keys( $result['node'] );
  	return node_load( array_pop( $keys ) );
  }

  else {
  	return FALSE;
  }
 }

/**
 * Supports the 'Services' style embed
function dlts_media_api_embed_using_uri() {

  $lookup_results = dlts_media_api_oembed_lookup();

  if ( $lookup_results['code'] !== 200 ) return $lookup_results;

  $nid = $lookup_results['nid'];

  return dlts_media_api_embed_response( node_load($nid), $lookup_results );

}
*/

/**
 * Supports the REST style embed
 */
function dlts_media_api_embed_using_id( $node ) {
  return ( is_object ( $node ) ) ? dlts_media_api_embed_response( $node ) : MENU_NOT_FOUND;
}


/**
 * Generate a response to a client oEmbed request.
 *
 * @return
 *   A keyed array to be converted into JSON
 *
 * @todo Test oembed_node for whether it's actually a node
 */
function dlts_media_api_embed_response( $node, $pre_response = array() ) {

  $argument_defaults = array(
    'format' => 'JSON',
	  'width' => 480,
	  'height' => 640,
	  'callback' => '',
	  'iframe' => TRUE,
	  'mode' => 'single_page',
  );

  $ewrapper = entity_metadata_wrapper('node', $node);

  $arguments = array_merge( $argument_defaults, $pre_response );

  $author = t('undefined');

  $author_url = t('undefined');

  /** representitive image */
  $thumbnail_url = '';

  if ( !empty($arguments['uri']['modified']) ) {
    $url = url( $arguments['uri']['modified'], array('query' => array ('oembed' => 'true'), 'absolute' => TRUE));
  }
  else {
    $url = url( $arguments['uri']['request'], array('query' => array ('oembed' => 'true')));
  }

  $response = array(
    'type' => 'rich',
    'version' => '1.0',
    'title' => $ewrapper->title->value(),
    'author_name' => $author,
    'author_url' => $author_url,
    'provider_name' => t('NYU Digital Library Technology Services'),
    'provider_url' => t('http://dlib.nyu.edu/'),
    'cache_age' => 86400,
    'thumbnail_url' => $thumbnail_url,
    'thumbnail_width' => 100,
    'thumbnail_height' => 154,
    'width' => (int) $arguments['width'],
    'height' => (int) $arguments['height'],
  );

  if ( $arguments['iframe'] ) {
    $response['html'] = theme('dlts_media_api_oembed', array( 'url' => $url, 'width' => $arguments['width'], 'height' => $arguments['height'] ) );
  }

  return $response;

}

/**
 * Themes functions
 */
function theme_dlts_media_api_oembed( $arguments ) {
  return '<iframe id="oembed" src="' . $arguments['url'] .'" width="' . $arguments['width'] .'" height="' . $arguments['height'] .'"><p>' . t('Your browser does not support iframes.') . '</p></iframe>';
}

/**
 * Implements hook_menu_alter.
 * Check access for forum menu item.
 */
function dlts_media_api_menu_alter(&$items) {
  $items['user/register']['access callback'] = FALSE;
  $items['user/password']['access callback'] = FALSE;
}
